#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Minerva Dispatcher job sweep command line script
"""
__docformat__ = "restructuredtext en"

__copyright__ = """
Copyright (C) 2013 Hendrikx-ITC B.V.

Distributed under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option) any later
version.  The full license is in the file COPYING, distributed as part of
this software.
"""
import os
import sys
import datetime
import argparse
import logging.handlers
import re
from contextlib import closing
import json
from functools import partial

from minerva.util import first
from minerva.util.config import load_config, get_defaults, ConfigError
from minerva.system.jobqueue import enqueue_job
from minerva.instance import MinervaInstance

from minerva_dispatcher import version, JOB_TYPE, get_job_sources

DELAY = 1800  # seconds

package_name = "minerva_dispatcher"
script_name = os.path.basename(__file__)
config_file = "{}.conf".format(script_name)


def main():
    """
    Script entry point
    """
    default_minerva_instance = os.environ.get("DEFAULT_MINERVA_INSTANCE",
                                              "default")

    config_file_path = os.path.join("/etc/minerva", config_file)

    parser = argparse.ArgumentParser(
        description="sweep job sources for existing files/jobs")

    parser.add_argument(
        "-v", "--version", action="version",
        version="%(prog)s {}".format(version.__version__))

    parser.add_argument(
        "-i", "--instance", default=default_minerva_instance,
        help="name of the target minerva instance")

    parser.add_argument("-u", "--user", help="user to connect to database")

    parser.add_argument(
        "-c", "--configfile", dest="configfile",
        default=config_file_path, help="the path to the config file")

    parser.add_argument(
        "--when-queue-empty", action="store_true",
        help="only run when the job queue is empty")

    parser.add_argument(
        "--generate-configfile", dest="generate_configfile",
        action=GenerateConfigFileAction, nargs=0,
        help="generate base config file")

    parser.add_argument(
        "--verbose", action="store_true", default=False,
        help="show verbose output")

    parser.add_argument(
        "--debug", action="store_true", default=False,
        help="show debug output")

    args = parser.parse_args()

    logging.root.addHandler(logging.StreamHandler())

    if args.verbose:
        logging.root.setLevel(logging.INFO)

    if args.debug:
        logging.root.setLevel(logging.DEBUG)

    minerva_instance = MinervaInstance.load(args.instance)

    try:
        config = load_config(get_defaults(package_name, config_file),
                             args.configfile)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    user = args.user or config["database"]["user"] or "minerva_admin"

    with closing(minerva_instance.connect(user=user)) as conn:
        with closing(conn.cursor()) as cursor:
            job_sources = get_job_sources(cursor, JOB_TYPE)

            if args.when_queue_empty:
                queue_size = get_queue_size(cursor)

                if queue_size > 0:
                    return

        conn.commit()

        for job_source_id, description in sweep(job_sources):
            process(conn, job_source_id, description)


def get_queue_size(cursor):
    query = "SELECT count(*) FROM system.job_queue"

    cursor.execute(query)

    return first(cursor.fetchone())


def sweep(job_sources):
    for job_source_id, name, job_type, config in job_sources:
        config_parsed = json.loads(config)

        match_pattern = config_parsed["match_pattern"]

        regex = re.compile(match_pattern)

        job_config = config_parsed["job_config"]

        uri = config_parsed["uri"]
        recursive = config_parsed["recursive"]

        logging.info("checking job source {} at {} with pattern {}".format(
            name, uri, match_pattern))

        if recursive:
            paths = (os.path.join(root, f) for root, _, files in os.walk(uri)
                     for f in files if regex.match(f))
        else:
            make_full_path = partial(os.path.join, uri)

            all_file_paths = map(make_full_path, os.listdir(uri))

            def file_matches(f):
                return os.path.isfile(f) and regex.match(f)

            paths = filter(file_matches, all_file_paths)

        def is_old(path):
            delay_delta = datetime.timedelta(seconds=DELAY)

            try:
                timestamp = os.path.getmtime(path)
            except OSError:
                return False
            else:
                modified = datetime.datetime.fromtimestamp(timestamp)

                return modified < (datetime.datetime.now() - delay_delta)

        for path in paths:
            logging.debug(path)

        for path in filter(is_old, paths):
            description = {"uri": path}
            description.update(job_config)

            yield job_source_id, description


def process(conn, job_source_id, job_description):
    path = job_description["uri"]

    try:
        filesize = os.path.getsize(path)
    except OSError as exc:
        logging.info("could not get size of file: {}".format(exc))
        return

    enqueue_job(conn, JOB_TYPE, json.dumps(job_description), filesize,
                job_source_id)

    conn.commit()

    logging.info("enqueued {}".format(path))


class GenerateConfigFileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        sys.stdout.write(get_defaults(package_name, config_file))
        sys.exit(0)


if __name__ == "__main__":
    main()
